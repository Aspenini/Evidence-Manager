name: Build — Windows / macOS (x64+arm64) / Linux (.AppImage + .deb)

on:
  workflow_dispatch:

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always
  BIN_NAME: evidence_manager       # <-- set to your binary name (without extension)
  APP_NAME: Evidence Manager       # Display name for Linux desktop entry
  # Update this if your binary needs a different exec name in .desktop:
  DESKTOP_EXEC: evidence_manager

jobs:
  build:
    name: Build (${{ matrix.os }} • ${{ matrix.target }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            arch: x86_64
            family: windows
          # macOS Intel
          - os: macos-13
            target: x86_64-apple-darwin
            arch: x86_64
            family: macos
          # macOS Apple Silicon
          - os: macos-14
            target: aarch64-apple-darwin
            arch: arm64
            family: macos
          # Linux x86_64 with packaging
          - os: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
            arch: x86_64
            family: linux
            do_linux_packages: "true"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Rust (stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # -------- Linux only: system dependencies (safe defaults for many GUI/CLI Rust apps) --------
      - name: Install Linux build dependencies
        if: ${{ matrix.family == 'linux' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential pkg-config libx11-dev libxi-dev libgl1-mesa-dev \
            libgtk-3-dev libasound2-dev libssl-dev zlib1g-dev

      # -------- Build (release) --------
      - name: Build (release)
        run: cargo build --release --target ${{ matrix.target }}

      # -------- Compute VERSION and output/basename --------
      - name: Compute version & names
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_REF:-}" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
          else
            VERSION="0.0.0-dev+$(git rev-parse --short HEAD)"
          fi
          OS_PRETTY="${{ matrix.family }}"
          ARCH="${{ matrix.arch }}"
          BIN_NAME="${{ env.BIN_NAME }}"

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "os_pretty=$OS_PRETTY" >> "$GITHUB_OUTPUT"
          echo "arch=$ARCH" >> "$GITHUB_OUTPUT"

          # Paths to built binaries per OS
          case "${{ matrix.family }}" in
            windows)
              echo "bin_path=target/${{ matrix.target }}/release/${BIN_NAME}.exe" >> "$GITHUB_OUTPUT"
              echo "artifact_name=${BIN_NAME}-${VERSION}-windows-${ARCH}.exe" >> "$GITHUB_OUTPUT"
              ;;
            macos)
              echo "bin_path=target/${{ matrix.target }}/release/${BIN_NAME}" >> "$GITHUB_OUTPUT"
              echo "artifact_name=${BIN_NAME}-${VERSION}-macos-${ARCH}" >> "$GITHUB_OUTPUT"
              ;;
            linux)
              echo "bin_path=target/${{ matrix.target }}/release/${BIN_NAME}" >> "$GITHUB_OUTPUT"
              echo "artifact_name=${BIN_NAME}-${VERSION}-linux-${ARCH}" >> "$GITHUB_OUTPUT"
              ;;
          esac

      # -------- Upload raw binaries for all platforms (useful regardless of packaging) --------
      - name: Upload raw binary
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}
          path: ${{ steps.meta.outputs.bin_path }}
          if-no-files-found: error

      # -------- Additionally tar.gz the macOS/Linux binaries --------
      - name: Tar.gz (macOS/Linux convenience)
        if: ${{ matrix.family == 'macos' || matrix.family == 'linux' }}
        shell: bash
        run: |
          set -euo pipefail
          cp "${{ steps.meta.outputs.bin_path }}" "./${{ steps.meta.outputs.artifact_name }}"
          tar -czf "${{ steps.meta.outputs.artifact_name }}.tar.gz" "${{ steps.meta.outputs.artifact_name }}"
      - name: Upload tar.gz (macOS/Linux)
        if: ${{ matrix.family == 'macos' || matrix.family == 'linux' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.artifact_name }}.tar.gz
          path: ${{ steps.meta.outputs.artifact_name }}.tar.gz
          if-no-files-found: error

      # ===================== Linux packaging: .AppImage + .deb =====================
      # Build .deb using cargo-deb (works out of the box; customize via Cargo.toml if desired)
      - name: Install cargo-deb
        if: ${{ matrix.do_linux_packages == 'true' }}
        run: cargo install cargo-deb

      - name: Build .deb
        if: ${{ matrix.do_linux_packages == 'true' }}
        run: cargo deb --target ${{ matrix.target }} --no-build
        # --no-build because we already built above; cargo-deb will reuse target artifacts

      - name: Find .deb and upload
        if: ${{ matrix.do_linux_packages == 'true' }}
        id: deb
        shell: bash
        run: |
          set -euo pipefail
          DEB=$(ls -1 target/${{ matrix.target }}/debian/*.deb | head -n1)
          echo "deb=$DEB" >> "$GITHUB_OUTPUT"
      - name: Upload .deb
        if: ${{ matrix.do_linux_packages == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BIN_NAME }}-${{ steps.meta.outputs.version }}-linux-${{ steps.meta.outputs.arch }}.deb
          path: ${{ steps.deb.outputs.deb }}
          if-no-files-found: error

      # Build .AppImage using linuxdeploy (no extra icon required; minimal .desktop is generated)
      - name: Prepare AppDir (desktop entry)
        if: ${{ matrix.do_linux_packages == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          APPDIR="$PWD/AppDir"
          mkdir -p "$APPDIR/usr/bin" "$APPDIR/usr/share/applications"
          # copy binary into AppDir
          cp "${{ steps.meta.outputs.bin_path }}" "$APPDIR/usr/bin/${{ env.DESKTOP_EXEC }}"
          chmod +x "$APPDIR/usr/bin/${{ env.DESKTOP_EXEC }}"

          cat > "$APPDIR/usr/share/applications/${{ env.BIN_NAME }}.desktop" <<EOF
          [Desktop Entry]
          Type=Application
          Name=${{ env.APP_NAME }}
          Exec=${{ env.DESKTOP_EXEC }}
          Icon=${{ env.BIN_NAME }}
          Terminal=false
          Categories=Utility;
          EOF

      - name: Download linuxdeploy
        if: ${{ matrix.do_linux_packages == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          curl -L -o linuxdeploy-x86_64.AppImage \
            https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
          chmod +x linuxdeploy-x86_64.AppImage

      - name: Build .AppImage
        if: ${{ matrix.do_linux_packages == 'true' }}
        shell: bash
        env:
          VERSION: ${{ steps.meta.outputs.version }}
        run: |
          set -euo pipefail
          # Run linuxdeploy to bundle and create AppImage
          ./linuxdeploy-x86_64.AppImage \
            --appdir AppDir \
            -e AppDir/usr/bin/${{ env.DESKTOP_EXEC }} \
            -d AppDir/usr/share/applications/${{ env.BIN_NAME }}.desktop \
            --output appimage

          # Move resulting AppImage to a clean name (linuxdeploy names it from .desktop)
          APPIMAGE_GLOB=$(ls -1 *.AppImage | head -n1)
          OUT="${{ env.BIN_NAME }}-${VERSION}-linux-${{ steps.meta.outputs.arch }}.AppImage"
          mv "$APPIMAGE_GLOB" "$OUT"
          echo "appimage=$OUT" >> $GITHUB_OUTPUT

      - name: Upload .AppImage
        if: ${{ matrix.do_linux_packages == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BIN_NAME }}-${{ steps.meta.outputs.version }}-linux-${{ steps.meta.outputs.arch }}.AppImage
          path: ${{ steps.build_AppImage.outputs.appimage || '*.AppImage' }}
          if-no-files-found: error
